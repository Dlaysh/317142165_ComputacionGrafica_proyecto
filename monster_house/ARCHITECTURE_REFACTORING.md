# Refactorización del Sistema de Objetos e Input

## ?? Objetivo Alcanzado

Se ha refactorizado completamente el sistema para que:
1. ? **Cada objeto recibe inputs globales** (teclado, mouse, tiempo)
2. ? **Cada objeto decide cómo actualizarse**
3. ? **El astronauta se mueve con la posición de la cámara**
4. ? **Arquitectura escalable y mantenible**

---

## ??? Nueva Arquitectura

### **1. InputState - Estructura de Inputs Globales**

```cpp
struct InputState {
    // Keyboard
    bool moveForward;
    bool moveBackward;
    bool rotateLeft;
    bool rotateRight;
    bool isRunning;
    
    // Mouse
    float mouseDeltaX;
    float mouseDeltaY;
    float scrollDelta;
    
    // Time
    float deltaTime;
    float totalTime;
};
```

**Ventajas:**
- ? Encapsula todos los inputs en una sola estructura
- ? Fácil de pasar a cualquier objeto
- ? Extensible (agregar nuevos inputs es trivial)

---

### **2. RenderableObject - Clase Base Actualizada**

```cpp
class RenderableObject {
public:
    virtual void update(const InputState& input) {}  // Nuevo método
    // ...resto de métodos
};
```

**Cambios:**
- `update()` ahora recibe `InputState` en lugar de solo `deltaTime`
- Los objetos pueden acceder a inputs y tiempo global
- Cada objeto decide qué hacer con los inputs

---

### **3. PlayerControlledObject - Nuevo Tipo de Objeto**

```cpp
class PlayerControlledObject : public RenderableObject {
private:
    float moveSpeed;
    float runMultiplier;
    float rotationSpeed;
    glm::vec3 forwardDirection;

public:
    void update(const InputState& input) override {
        // Rotation
        if (input.rotateLeft) rotation.y += rotationSpeed;
        if (input.rotateRight) rotation.y -= rotationSpeed;
        
        // Update forward direction
        updateForwardDirection();
        
        // Movement with speed
        float speed = input.isRunning ? moveSpeed * runMultiplier : moveSpeed;
        if (input.moveForward) position += speed * forwardDirection;
        if (input.moveBackward) position -= speed * forwardDirection;
    }
    
    glm::vec3 getForwardDirection() const;
};
```

**Características:**
- ? Controla su propia posición y rotación
- ? Responde a inputs de teclado (WASD/Flechas)
- ? Soporta sprint (Shift)
- ? Calcula su dirección forward automáticamente

---

### **4. InputController - Refactorizado**

```cpp
class InputController {
private:
    InputState currentInput;
    PlayerControlledObject* playerObject;

public:
    void processKeyboard(GLFWwindow* window) {
        // Captura estado del teclado
        currentInput.moveForward = (glfwGetKey(...) == GLFW_PRESS);
        currentInput.isRunning = (glfwGetKey(SHIFT) == GLFW_PRESS);
        // ...
    }
    
    void updateCameras() {
        // Sincroniza cámaras con la posición del jugador
        glm::vec3 playerPos = playerObject->getPosition();
        glm::vec3 forwardDir = playerObject->getForwardDirection();
        
        camera.Position = playerPos + offset;
        camera3rd.Position = playerPos - forwardDir * distance + offset;
    }
    
    const InputState& getInputState() const { return currentInput; }
};
```

**Responsabilidades:**
- ? Captura inputs del hardware (teclado/mouse)
- ? Genera `InputState`
- ? Sincroniza cámaras con el jugador
- ? Maneja cambio de cámara (C)

---

### **5. SceneManager - Simplificado**

```cpp
class SceneManager {
public:
    void update(const InputState& input) {
        for (auto& obj : objects) {
            obj->update(input);  // Propaga input a todos
        }
    }
};
```

**Cambios:**
- Ya no maneja variables globales `position` y `rotateCharacter`
- Simplemente propaga `InputState` a todos los objetos
- Cada objeto decide qué hacer con la información

---

## ?? Flujo de Ejecución

```
???????????????????????????????????????????????????????????????
?                     FRAME LOOP                              ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  1. InputController::processKeyboard()                      ?
?     - Captura teclas presionadas                            ?
?     - Actualiza InputState                                  ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  2. InputController::processMouse()                         ?
?     - Captura movimiento del mouse                          ?
?     - Actualiza deltasX/Y en InputState                     ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  3. Update()                                                ?
?     - Obtiene InputState del controller                     ?
?     - Agrega deltaTime y totalTime                          ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  4. SceneManager::update(InputState)                        ?
?     - Propaga input a TODOS los objetos                     ?
?     - Cada objeto se actualiza según sus reglas             ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  5. PlayerControlledObject::update(InputState)              ?
?     - Procesa inputs de movimiento                          ?
?     - Actualiza position y rotation                         ?
?     - Calcula forwardDirection                              ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  6. OrbitingMoonObject::update(InputState)                  ?
?     - Ignora inputs de teclado/mouse                        ?
?     - Usa totalTime para órbita                             ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  7. InputController::updateCameras()                        ?
?     - Lee position del PlayerObject                         ?
?     - Actualiza Camera.Position                             ?
?     - Actualiza Camera3rd.Position                          ?
???????????????????????????????????????????????????????????????
                              ?
???????????????????????????????????????????????????????????????
?  8. SceneManager::render()                                  ?
?     - Renderiza todos los objetos                           ?
???????????????????????????????????????????????????????????????
```

---

## ?? Sincronización Cámara-Jugador

### **Antes (Problemático):**
```
Variables Globales:
?? position (global)
?? rotateCharacter (global)
?? forwardView (global)

Problema: 
- Múltiples fuentes de verdad
- Difícil de sincronizar
- Variables sueltas por todos lados
```

### **Después (Correcto):**
```
PlayerControlledObject
?? position (interna)
?? rotation (interna)
?? forwardDirection (interna)
        ?
InputController::updateCameras()
?? Lee playerObject->getPosition()
?? Lee playerObject->getForwardDirection()
?? Actualiza camera.Position
?? Actualiza camera3rd.Position

Ventaja:
? Una sola fuente de verdad (el objeto jugador)
? Sincronización automática
? Sin variables globales sueltas
```

---

## ?? Comparación de Comportamientos

| Objeto | Usa Inputs Teclado | Usa Mouse | Usa Tiempo | Actualiza Posición |
|--------|-------------------|-----------|------------|-------------------|
| **PlayerControlledObject** | ? WASD/Flechas | ? No | ? No | ? Sí |
| **AnimatedPlayerControlledObject** | ? WASD/Flechas | ? No | ? Animación | ? Sí |
| **OrbitingMoonObject** | ? No | ? No | ? Órbita | ? Sí (calculada) |
| **RenderableObject** (base) | ? No | ? No | ? No | ? No (estático) |

---

## ?? Cómo Agregar un Nuevo Tipo de Objeto

### **Ejemplo: Objeto que sigue al jugador**

```cpp
class FollowerObject : public RenderableObject {
private:
    glm::vec3 targetPosition;
    float followSpeed;

public:
    FollowerObject(Model* mdl, Shader* shdr, glm::vec3 pos, glm::vec3 scl)
        : RenderableObject(mdl, shdr, pos, glm::vec3(0.0f), scl),
          targetPosition(pos), followSpeed(0.05f) {}

    void update(const InputState& input) override {
        // Obtener posición del jugador
        if (g_playerObject) {
            targetPosition = g_playerObject->getPosition();
            targetPosition.y += 2.0f;  // Flotar sobre el jugador
        }
        
        // Moverse suavemente hacia el target
        glm::vec3 direction = targetPosition - position;
        position += direction * followSpeed * input.deltaTime;
    }
};
```

### **Uso:**
```cpp
// En Start()
auto followerObj = std::make_unique<FollowerObject>(
    followerModel, shader, glm::vec3(0.0f, 3.0f, 0.0f), glm::vec3(1.0f));
sceneManager->addObject(std::move(followerObj));
```

---

## ?? Ventajas de la Nueva Arquitectura

### **1. Extensibilidad**
```cpp
// Agregar nuevo input es trivial
struct InputState {
    // ...existentes
    bool jump;          // ? Agregar nuevo
    bool interact;      // ? Agregar nuevo
};
```

### **2. Responsabilidad Clara**
```
InputController ? Captura inputs
PlayerObject ? Controla movimiento
SceneManager ? Coordina objetos
Cada clase tiene UNA responsabilidad
```

### **3. Sin Variables Globales Sueltas**
```
Antes: ?
?? position (global)
?? rotateCharacter (global)
?? forwardView (global)

Después: ?
?? PlayerControlledObject (todo encapsulado)
```

### **4. Fácil de Debuggear**
```cpp
void PlayerControlledObject::update(const InputState& input) {
    // Punto de interrupción aquí
    // Puedes ver exactamente qué inputs recibe
    // y cómo afectan la posición
}
```

### **5. Testeable**
```cpp
// Crear input state de prueba
InputState testInput;
testInput.moveForward = true;
testInput.deltaTime = 0.016f;

// Probar objeto
PlayerControlledObject player(...);
player.update(testInput);

// Verificar resultado
assert(player.getPosition().z > initialZ);
```

---

## ?? Controles Finales

```
???????????????????????????????????????????????????
?  CONTROLES DEL JUGADOR                          ?
???????????????????????????????????????????????????
?  W / ?              ?  Mover adelante           ?
?  S / ?              ?  Mover atrás              ?
?  A / ?              ?  Rotar izquierda          ?
?  D / ?              ?  Rotar derecha            ?
?  Shift + Movimiento ?  Correr (2.5x velocidad)  ?
???????????????????????????????????????????????????
?  CÁMARA                                         ?
???????????????????????????????????????????????????
?  C                  ?  Cambiar 1ª ? 3ª persona  ?
?  Mouse Horizontal   ?  Rotar cámara             ?
?  Scroll (1ª pers.)  ?  Mirar ? (±50°)           ?
?  Scroll (3ª pers.)  ?  Zoom (1.0-15.0)          ?
???????????????????????????????????????????????????
?  OTROS                                          ?
???????????????????????????????????????????????????
?  L                  ?  Toggle indicadores luz   ?
?  ESC                ?  Salir                    ?
???????????????????????????????????????????????????
```

---

## ?? Comportamiento de Cámaras

### **Primera Persona:**
```
     ??? Camera
      |
      | (mira en dirección de rotation.y + pitch)
      |
    ?? Player (position)
```

### **Tercera Persona:**
```
    ?? Player (position)
     ?
     | forwardDirection
     ?
    ??? Camera (position - offset * forwardDirection)
```

---

## ?? Mejoras Futuras Posibles

### **1. Sistema de Animaciones**
```cpp
if (input.moveForward && input.isRunning) {
    playAnimation("run");
} else if (input.moveForward) {
    playAnimation("walk");
} else {
    playAnimation("idle");
}
```

### **2. Sistema de Físicas**
```cpp
class PhysicsObject : public RenderableObject {
    void update(const InputState& input) override {
        velocity += gravity * input.deltaTime;
        position += velocity * input.deltaTime;
        // Collision detection...
    }
};
```

### **3. Sistema de IA**
```cpp
class AIObject : public RenderableObject {
    void update(const InputState& input) override {
        // Decide acción basándose en estado del mundo
        if (distanceToPlayer < 10.0f) {
            moveTowards(g_playerObject->getPosition());
        }
    }
};
```

---

## ? Resumen de Cambios

| Aspecto | Antes | Después |
|---------|-------|---------|
| **Inputs** | Variables globales | `InputState` struct |
| **Jugador** | Variables `position`, `rotateCharacter` | `PlayerControlledObject` |
| **Actualización** | `update(deltaTime)` | `update(InputState)` |
| **Cámaras** | Actualizadas en `Update()` | Sincronizadas con jugador |
| **Arquitectura** | Acoplada | Desacoplada y escalable |
| **Extensibilidad** | Difícil | Trivial |

---

## ?? Conclusión

La refactorización ha logrado:

? **Arquitectura limpia y profesional**
? **Cada objeto controla su propio comportamiento**
? **Cámaras sincronizadas automáticamente con el jugador**
? **Sistema extensible para nuevos tipos de objetos**
? **Código mantenible y testeable**
? **Sin variables globales sueltas**

¡El comportamiento se mantiene exactamente igual pero con una arquitectura mucho mejor! ???
